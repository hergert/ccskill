#!/bin/bash
# ccskill - Manage Claude Code and Codex skills across projects
# Requires: gum (brew install gum)

set -euo pipefail

SKILL_REGISTRY="${SKILL_REGISTRY:-$HOME/.skills}"
PROJECT_SKILLS_CLAUDE=".claude/skills"
PROJECT_SKILLS_CODEX=".codex/skills"
TARGET_MODE="${CCSKILL_TARGET:-auto}"
YES_FLAG=false

# Colors via gum
info() { gum style --foreground 39 "$@"; }
success() { gum style --foreground 77 "✓ $*"; }
warn() { gum style --foreground 214 "⚠ $*"; }
error() { gum style --foreground 196 "✗ $*"; }
dim() { gum style --foreground 240 "$@"; }

# Confirm with --yes support
confirm() {
    [[ "$YES_FLAG" == true ]] && return 0
    gum confirm "$@"
}

# Check dependencies
check_deps() {
    if ! command -v gum &>/dev/null; then
        echo "Error: gum is required. Install with: brew install gum"
        exit 1
    fi
}

# Get list of available skills from registry
available_skills() {
    if [[ ! -d "$SKILL_REGISTRY" ]]; then
        error "Registry not found at $SKILL_REGISTRY"
        echo "Run: ccskill init"
        exit 1
    fi

    for dir in "$SKILL_REGISTRY"/*/; do
        [[ -f "$dir/SKILL.md" ]] && basename "$dir"
    done
}

# Resolve target to project path
target_dir() {
    case "$1" in
        claude) echo "$PROJECT_SKILLS_CLAUDE" ;;
        codex) echo "$PROJECT_SKILLS_CODEX" ;;
        *) echo "" ;;
    esac
}

# Resolve target to label
target_label() {
    case "$1" in
        claude) echo "Claude" ;;
        codex) echo "Codex" ;;
        *) echo "Unknown" ;;
    esac
}

# Determine targets without prompting (respects CCSKILL_TARGET)
determine_targets() {
    local mode="$TARGET_MODE"
    case "$mode" in
        claude|claude-code|claudecode) echo "claude" ;;
        codex|codex-code) echo "codex" ;;
        both) echo "claude codex" ;;
        auto|"")
            local present=()
            [[ -d "$PROJECT_SKILLS_CLAUDE" || -d ".claude" ]] && present+=("claude")
            [[ -d "$PROJECT_SKILLS_CODEX" || -d ".codex" ]] && present+=("codex")

            if [[ ${#present[@]} -eq 2 ]]; then
                echo "claude codex"
            elif [[ ${#present[@]} -eq 1 ]]; then
                echo "${present[0]}"
            else
                echo "claude"
            fi
            ;;
        *)
            error "Unknown CCSKILL_TARGET: $mode (use claude|codex|both|auto)"
            exit 1
            ;;
    esac
}

select_targets_only() {
    check_deps
    if [[ ! -t 1 ]]; then
        determine_targets
        return
    fi

    local selection
    selection=$(printf "[target] Claude\n[target] Codex" | gum choose --no-limit --header "Select target(s):") || return

    SELECTED_TARGETS=()
    while IFS= read -r line; do
        case "$line" in
            "[target] "*)
                local t="${line#"[target] "}"
                t="$(printf "%s" "$t" | tr '[:upper:]' '[:lower:]')"
                SELECTED_TARGETS+=("$t")
                ;;
        esac
    done <<< "$selection"

    if [[ ${#SELECTED_TARGETS[@]} -eq 0 ]]; then
        return 1
    fi

    printf "%s " "${SELECTED_TARGETS[@]}" | sed 's/ $//'
}

select_targets_and_skills() {
    local header="$1"
    shift
    local skills=("$@")

    check_deps
    if [[ ! -t 1 ]]; then
        return 1
    fi

    if [[ ${#skills[@]} -eq 0 ]]; then
        warn "No skills available to select"
        return 1
    fi

    local items=()
    for s in "${skills[@]}"; do
        items+=("[skill] $s")
    done
    items+=("----------")
    items+=("[target] Claude")
    items+=("[target] Codex")

    local selection
    selection=$(printf "%s\n" "${items[@]}" | gum choose --no-limit --header "$header") || return

    SELECTED_TARGETS=()
    SELECTED_SKILLS=()
    while IFS= read -r line; do
        case "$line" in
            "[target] "*)
                local t="${line#"[target] "}"
                t="$(printf "%s" "$t" | tr '[:upper:]' '[:lower:]')"
                SELECTED_TARGETS+=("$t")
                ;;
            "[skill] "*)
                SELECTED_SKILLS+=("${line#"[skill] "}")
                ;;
        esac
    done <<< "$selection"

    if [[ ${#SELECTED_SKILLS[@]} -eq 0 ]]; then
        warn "Select at least one skill"
        return 1
    fi
}

targets_for_skill_installed() {
    local skill="$1"
    local targets=()
    local dir
    dir="$(target_dir "claude")"
    is_installed_dir "$dir" "$skill" && targets+=("claude")
    dir="$(target_dir "codex")"
    is_installed_dir "$dir" "$skill" && targets+=("codex")
    printf "%s " "${targets[@]}" | sed 's/ $//'
}

installed_pairs() {
    local entries=()
    local dir
    dir="$(target_dir "claude")"
    if [[ -d "$dir" ]]; then
        for d in "$dir"/*/; do
            [[ -f "$d/SKILL.md" ]] || continue
            entries+=("$(basename "$d") :: Claude")
        done
    fi
    dir="$(target_dir "codex")"
    if [[ -d "$dir" ]]; then
        for d in "$dir"/*/; do
            [[ -f "$d/SKILL.md" ]] || continue
            entries+=("$(basename "$d") :: Codex")
        done
    fi
    printf "%s\n" "${entries[@]}" | sort
}

# Get list of installed skills in target directory
installed_skills_dir() {
    local dir="$1"
    [[ -z "$dir" || ! -d "$dir" ]] && return

    for d in "$dir"/*/; do
        [[ -f "$d/SKILL.md" ]] && basename "$d"
    done
}

# Check if skill is installed in target directory
is_installed_dir() {
    local dir="$1"
    local skill="$2"
    [[ -n "$dir" && -d "$dir/$skill" ]]
}

# Get skill description from SKILL.md frontmatter
skill_description() {
    local skill="$1"
    local skill_file="$SKILL_REGISTRY/$skill/SKILL.md"
    [[ -f "$skill_file" ]] || return

    # Extract description from YAML frontmatter
    sed -n '/^---$/,/^---$/p' "$skill_file" | grep '^description:' | sed 's/description: //'
}

# ============================================================================
# Commands
# ============================================================================

cmd_info() {
    local skill="$1"

    if [[ -z "$skill" ]]; then
        error "Usage: ccskill info <skill>"
        return 1
    fi

    local skill_file="$SKILL_REGISTRY/$skill/SKILL.md"
    if [[ ! -f "$skill_file" ]]; then
        error "Skill '$skill' not found"
        return 1
    fi

    # Try gum pager, fall back to cat
    if command -v gum &>/dev/null && [[ -t 1 ]]; then
        gum pager < "$skill_file"
    else
        cat "$skill_file"
    fi
}

cmd_list() {
    check_deps
    local targets
    targets=($(determine_targets))

    if [[ ${#targets[@]} -gt 1 ]]; then
        for t in "${targets[@]}"; do
            gum style --bold "$(target_label "$t") skills"
            echo ""
            cmd_list_target "$t"
            echo ""
        done
    else
        cmd_list_target "${targets[0]}"
    fi
}

cmd_list_target() {
    local target="$1"
    local project_dir
    project_dir="$(target_dir "$target")"

    local available
    available=$(available_skills)

    if [[ -z "$available" ]]; then
        warn "No skills found in registry"
        return
    fi

    local installed_count=0
    local total_count=0
    for skill in $available; do
        ((total_count++))
        is_installed_dir "$project_dir" "$skill" && ((installed_count++))
    done

    gum style --bold "Skills ($installed_count/$total_count installed)"
    echo ""

    for skill in $available; do
        local marker=" "
        is_installed_dir "$project_dir" "$skill" && marker=$(gum style --foreground 77 "✓")

        local desc
        desc=$(skill_description "$skill" | head -c 50)

        printf "  %s %-14s %s\n" "$marker" "$skill" "$(dim "$desc")"
    done
}

cmd_status() {
    check_deps
    local targets
    targets=($(determine_targets))

    if [[ ${#targets[@]} -gt 1 ]]; then
        for t in "${targets[@]}"; do
            cmd_status_target "$t"
            echo ""
        done
    else
        cmd_status_target "${targets[0]}"
    fi
}

cmd_status_target() {
    local target="$1"
    local project_dir
    project_dir="$(target_dir "$target")"
    local label
    label="$(target_label "$target")"

    if [[ ! -d "$project_dir" ]]; then
        warn "No skills installed for $label. Run: ccskill add <name> --target $target"
        return
    fi

    local installed
    installed=$(installed_skills_dir "$project_dir")

    if [[ -z "$installed" ]]; then
        warn "No skills installed for $label"
        return
    fi

    local updates=0
    for skill in $installed; do
        if [[ -d "$SKILL_REGISTRY/$skill" ]] && ! diff -rq "$SKILL_REGISTRY/$skill" "$project_dir/$skill" &>/dev/null; then
            ((updates++))
        fi
    done

    if [[ $updates -gt 0 ]]; then
        gum style --bold "$label ( $updates updates available )"
    else
        gum style --bold "$label (all up to date)"
    fi
    echo ""

    for skill in $installed; do
        local marker
        if [[ -d "$SKILL_REGISTRY/$skill" ]]; then
            if ! diff -rq "$SKILL_REGISTRY/$skill" "$project_dir/$skill" &>/dev/null; then
                marker=$(gum style --foreground 214 "↑")
            else
                marker=$(gum style --foreground 77 "✓")
            fi
        else
            marker=$(gum style --foreground 196 "?")
        fi

        printf "  %s %s\n" "$marker" "$skill"
    done
}

cmd_add() {
    check_deps
    local skill="$1"
    local targets=()

    if [[ -z "$skill" ]]; then
        if [[ ! -t 1 ]]; then
            error "Non-interactive add requires a skill name"
            return 1
        fi

        local available_list=()
        while IFS= read -r line; do
            [[ -n "$line" ]] && available_list+=("$line")
        done < <(available_skills)

        if ! select_targets_and_skills "Select skills to add (targets optional below)" "${available_list[@]}"; then
            return
        fi

        local targets=("${SELECTED_TARGETS[@]}")
        if [[ ${#targets[@]} -eq 0 ]]; then
            targets=($(determine_targets))
        fi

        for s in "${SELECTED_SKILLS[@]}"; do
            for t in "${targets[@]}"; do
                add_skill_to_target "$s" "$t"
            done
        done
        return
    fi

    # Validate skill exists
    if [[ ! -d "$SKILL_REGISTRY/$skill" ]]; then
        error "Skill '$skill' not found in registry"
        return 1
    fi

    if [[ -t 1 ]]; then
        targets=($(select_targets_only)) || return
    else
        targets=($(determine_targets))
    fi

    for t in "${targets[@]}"; do
        add_skill_to_target "$skill" "$t"
    done
}

# Post-add setup: install deps if skill has package.json or setup.sh
post_add_setup() {
    local skill_dir="$1"

    if [[ -f "$skill_dir/scripts/setup.sh" ]]; then
        if confirm "Run setup for $(basename "$skill_dir")?"; then
            info "Running setup..."
            if bash "$skill_dir/scripts/setup.sh"; then
                success "Setup complete"
            else
                warn "Setup had errors — run manually: bash $skill_dir/scripts/setup.sh"
            fi
        else
            dim "  Skipped. Run later: bash $skill_dir/scripts/setup.sh"
        fi
    elif [[ -f "$skill_dir/package.json" ]]; then
        info "Installing dependencies..."
        if command -v bun &>/dev/null; then
            (cd "$skill_dir" && bun install --no-save 2>&1 | tail -3)
        elif command -v npm &>/dev/null; then
            (cd "$skill_dir" && npm install 2>&1 | tail -3)
        else
            warn "No package manager found — install deps manually in $skill_dir"
        fi
    fi
}

add_skill_to_target() {
    local skill="$1"
    local target="$2"
    local project_dir
    project_dir="$(target_dir "$target")"
    local label
    label="$(target_label "$target")"

    if [[ -z "$project_dir" ]]; then
        error "Invalid target: $target"
        return 1
    fi

    if is_installed_dir "$project_dir" "$skill"; then
        warn "Skill '$skill' already installed for $label"
        return 0
    fi

    mkdir -p "$project_dir"

    gum spin --spinner dot --title "Adding $skill ($label)..." -- \
        cp -R "$SKILL_REGISTRY/$skill" "$project_dir/$skill"

    success "Added $skill ($label)"
    dim "  Location: $project_dir/$skill"

    # Post-add: run setup if skill has deps
    post_add_setup "$project_dir/$skill"
}

cmd_remove() {
    check_deps
    local skill="$1"
    local targets=()

    if [[ -z "$skill" ]]; then
        if [[ ! -t 1 ]]; then
            error "Non-interactive remove requires a skill name"
            return 1
        fi

        local pairs=()
        while IFS= read -r line; do
            [[ -n "$line" ]] || continue
            pairs+=("$line")
        done < <(installed_pairs)

        if [[ ${#pairs[@]} -eq 0 ]]; then
            warn "No skills installed"
            return
        fi

        local selection
        selection=$(printf "%s\n" "${pairs[@]}" | gum choose \
            --no-limit \
            --selected-prefix="✓ " \
            --unselected-prefix="  " \
            --cursor-prefix="> " \
            --header "Select items to remove") || return

        local selections=()
        while IFS= read -r line; do
            [[ -n "$line" ]] && selections+=("$line")
        done <<< "$selection"

        if [[ ${#selections[@]} -eq 0 ]]; then
            dim "Cancelled"
            return
        fi

        if ! confirm "Remove ${#selections[@]} selection(s)?"; then
            dim "Cancelled"
            return
        fi

        for line in "${selections[@]}"; do
            local skill_name="${line%% :: *}"
            local label="${line##* :: }"
            local target
            target="$(printf "%s" "$label" | tr '[:upper:]' '[:lower:]')"
            local project_dir
            project_dir="$(target_dir "$target")"
            if [[ -z "$project_dir" ]]; then
                continue
            fi
            if is_installed_dir "$project_dir" "$skill_name"; then
                rm -rf "$project_dir/$skill_name"
                success "Removed $skill_name ($label)"
            else
                dim "  Not installed for $label: $skill_name"
            fi
        done
        return
    fi

    if [[ -t 1 ]]; then
        targets=($(select_targets_only)) || return
    else
        targets=($(determine_targets))
    fi

    # Confirm removal once for all targets
    local target_label
    if [[ ${#targets[@]} -gt 1 ]]; then
        target_label="Claude + Codex"
    else
        target_label="$(target_label "${targets[0]}")"
    fi

    if ! confirm "Remove skill '$skill' from $target_label?"; then
        dim "Cancelled"
        return
    fi

    for t in "${targets[@]}"; do
        local project_dir
        project_dir="$(target_dir "$t")"
        local label
        label="$(target_label "$t")"
        if is_installed_dir "$project_dir" "$skill"; then
            rm -rf "$project_dir/$skill"
            success "Removed $skill ($label)"
        else
            dim "  Not installed for $label"
        fi
    done
}

installed_union() {
    local targets=("$@")
    for t in "${targets[@]}"; do
        installed_skills_dir "$(target_dir "$t")"
    done | sort -u
}

cmd_update() {
    check_deps
    local skill="$1"
    local targets=()

    if [[ -z "$skill" ]]; then
        if [[ ! -t 1 ]]; then
            error "Non-interactive update requires a skill name"
            return 1
        fi

        local installed_list=()
        while IFS= read -r line; do
            [[ -n "$line" ]] && installed_list+=("$line")
        done < <(installed_union "claude" "codex")

        if [[ ${#installed_list[@]} -eq 0 ]]; then
            warn "No skills installed"
            return
        fi

        if ! select_targets_and_skills "Select skills to update (targets optional below)" "${installed_list[@]}"; then
            return
        fi

        local explicit_targets=("${SELECTED_TARGETS[@]}")
        for s in "${SELECTED_SKILLS[@]}"; do
            local targets=("${explicit_targets[@]}")
            if [[ ${#targets[@]} -eq 0 ]]; then
                targets=($(targets_for_skill_installed "$s"))
            fi
            if [[ ${#targets[@]} -eq 0 ]]; then
                dim "  Not installed: $s"
                continue
            fi

            for t in "${targets[@]}"; do
                cmd_update_target "$t" "$s"
            done
        done
        return
    fi

    if [[ -t 1 ]]; then
        targets=($(select_targets_only)) || return
    else
        targets=($(determine_targets))
    fi

    for t in "${targets[@]}"; do
        cmd_update_target "$t" "$skill"
    done
}

cmd_update_target() {
    local target="$1"
    local skill="$2"
    local project_dir
    project_dir="$(target_dir "$target")"
    local label
    label="$(target_label "$target")"

    if [[ ! -d "$project_dir" ]]; then
        warn "No skills installed for $label"
        return
    fi

    if [[ -z "$skill" ]]; then
        # Find skills with updates available
        local with_updates=""
        for s in $(installed_skills_dir "$project_dir"); do
            if [[ -d "$SKILL_REGISTRY/$s" ]] && ! diff -rq "$SKILL_REGISTRY/$s" "$project_dir/$s" &>/dev/null; then
                with_updates="$with_updates$s"$'\n'
            fi
        done
        with_updates=$(echo "$with_updates" | sed '/^$/d')

        if [[ -z "$with_updates" ]]; then
            success "$label: all skills up to date"
            return
        fi

        local count
        count=$(echo "$with_updates" | wc -l | tr -d ' ')

        local choice
        if [[ $count -eq 1 ]]; then
            choice="$with_updates"
        else
            choice=$(echo -e "Update all ($count)\n$with_updates" | gum choose --header "Select $label skill to update:")
        fi

        if [[ -z "$choice" ]]; then
            return
        fi

        if [[ "$choice" == "Update all"* ]]; then
            for s in $with_updates; do
                cmd_update_target "$target" "$s"
            done
            return
        fi

        skill="$choice"
        [[ -z "$skill" ]] && return
    fi

    # Validate skill is installed
    if ! is_installed_dir "$project_dir" "$skill"; then
        error "$label: Skill '$skill' not installed"
        return 1
    fi

    # Validate skill exists in registry
    if [[ ! -d "$SKILL_REGISTRY/$skill" ]]; then
        error "Skill '$skill' not found in registry"
        return 1
    fi

    # Check if update needed
    if diff -rq "$SKILL_REGISTRY/$skill" "$project_dir/$skill" &>/dev/null; then
        success "$label: $skill is already up to date"
        return
    fi

    # Show diff
    gum style --bold --border normal --padding "0 1" --margin "1 0" \
        "Changes in $skill ($label)"

    # Generate diff
    local diff_output
    diff_output=$(diff -rq "$project_dir/$skill" "$SKILL_REGISTRY/$skill" 2>/dev/null || true)

    if [[ -n "$diff_output" ]]; then
        echo "$diff_output" | while read -r line; do
            if [[ "$line" == *"Only in $project_dir"* ]]; then
                gum style --foreground 196 "  - $(echo "$line" | sed 's/Only in.*: /removed: /')"
            elif [[ "$line" == *"Only in $SKILL_REGISTRY"* ]]; then
                gum style --foreground 77 "  + $(echo "$line" | sed 's/Only in.*: /added: /')"
            elif [[ "$line" == *"differ"* ]]; then
                gum style --foreground 214 "  ~ $(echo "$line" | sed 's/Files .* and .* differ/modified:/' | sed "s|$project_dir/$skill/||")"
            fi
        done
    fi

    # Show SKILL.md diff preview
    if ! diff -q "$project_dir/$skill/SKILL.md" "$SKILL_REGISTRY/$skill/SKILL.md" &>/dev/null 2>&1; then
        echo ""
        if confirm "Show SKILL.md diff for $label?"; then
            diff -u "$project_dir/$skill/SKILL.md" "$SKILL_REGISTRY/$skill/SKILL.md" | head -40 || true
        fi
    fi

    echo ""
    if ! confirm "Apply update to $skill for $label?"; then
        dim "Cancelled"
        return
    fi

    # Update
    rm -rf "$project_dir/$skill"
    cp -R "$SKILL_REGISTRY/$skill" "$project_dir/$skill"

    success "Updated $skill ($label)"
}

cmd_init() {
    check_deps

    if [[ -d "$SKILL_REGISTRY" ]]; then
        info "Registry already exists at $SKILL_REGISTRY"
        local count
        count=$(available_skills | wc -l | tr -d ' ')
        dim "  $count skills available"
        return
    fi

    gum style --bold "Initialize skill registry"
    echo ""

    # Ask for source
    local source
    source=$(gum choose --header "Initialize from:" \
        "Empty (create manually)" \
        "Git repository")

    case "$source" in
        "Empty"*)
            mkdir -p "$SKILL_REGISTRY"
            success "Created empty registry at $SKILL_REGISTRY"
            dim "  Add skills manually to this directory"
            ;;
        "Git"*)
            local repo
            repo=$(gum input --placeholder "https://github.com/user/skills.git")
            [[ -z "$repo" ]] && return

            gum spin --spinner dot --title "Cloning..." -- \
                git clone "$repo" "$SKILL_REGISTRY"

            success "Initialized registry from $repo"
            ;;
    esac
}

cmd_help() {
    cat <<'EOF'
ccskill - Manage Claude Code and Codex skills across projects

USAGE
    ccskill <command> [args]

COMMANDS
    list              Show available skills from registry
    status            Show installed skills + update status
    info <name>       Show full skill details (SKILL.md)
    add [name]        Add skill to current project
    remove [name]     Remove skill from current project
    update [name]     Update skill(s) with diff preview
    sync              Pull latest skills from git remote
    upgrade           Update ccskill itself from source repo
    doctor            Check system health + diagnose issues
    init              Initialize skill registry

OPTIONS
    -y, --yes         Skip confirmations (for scripts)

EXAMPLES
    ccskill list                  # See what's available
    ccskill info posthog          # View skill details
    ccskill add posthog           # Add to this project
    ccskill add posthog --yes     # Add without confirmation
    ccskill status                # Check for updates
    ccskill update                # Update skills
    CCSKILL_TARGET=codex ccskill add posthog   # Scripted target

INSTALL
    # Add to PATH (add to ~/.zshrc or ~/.bashrc)
    export PATH="$HOME/.skills:$PATH"

NOTES
    Target selection is interactive for add/remove/update when a TTY is
    available. To force a target in scripts, set CCSKILL_TARGET to
    claude, codex, or both.
EOF
}

cmd_sync() {
    check_deps

    if [[ ! -d "$SKILL_REGISTRY/.git" ]]; then
        warn "Registry is not a git repository"
        dim "  Can't sync without git"
        return 1
    fi

    gum spin --spinner dot --title "Syncing registry..." -- \
        git -C "$SKILL_REGISTRY" pull --rebase

    success "Registry synced"

    # Show if any installed skills have updates
    if [[ -d "$PROJECT_SKILLS_CLAUDE" || -d "$PROJECT_SKILLS_CODEX" ]]; then
        echo ""
        cmd_status
    fi
}

# Find git root containing the registry
registry_git_root() {
    local dir="$SKILL_REGISTRY"
    while [[ "$dir" != "/" ]]; do
        if [[ -d "$dir/.git" ]]; then
            echo "$dir"
            return
        fi
        dir="$(dirname "$dir")"
    done
}

cmd_upgrade() {
    check_deps

    local git_root
    git_root="$(registry_git_root)"

    if [[ -z "$git_root" ]]; then
        error "Registry is not inside a git repo — can't find source"
        dim "  Registry: $SKILL_REGISTRY"
        return 1
    fi

    local source_script="$git_root/ccskill"
    if [[ ! -f "$source_script" ]]; then
        error "No ccskill found in repo root: $git_root"
        return 1
    fi

    local installed_script
    installed_script="$(command -v ccskill 2>/dev/null || echo "")"

    if [[ -z "$installed_script" ]]; then
        error "ccskill not found on PATH"
        return 1
    fi

    # Resolve symlinks
    installed_script="$(realpath "$installed_script")"
    source_script="$(realpath "$source_script")"

    if [[ "$installed_script" == "$source_script" ]]; then
        success "Already running from source"
        return
    fi

    if diff -q "$installed_script" "$source_script" &>/dev/null; then
        success "ccskill is up to date"
        return
    fi

    info "Update available"
    dim "  Source:    $source_script"
    dim "  Installed: $installed_script"

    if ! confirm "Upgrade ccskill?"; then
        dim "Cancelled"
        return
    fi

    cp "$source_script" "$installed_script"
    chmod +x "$installed_script"
    success "ccskill upgraded"
}

cmd_doctor() {
    check_deps
    local issues=0

    gum style --bold "ccskill doctor"
    echo ""

    # Registry
    if [[ -d "$SKILL_REGISTRY" ]]; then
        success "Registry: $SKILL_REGISTRY"
    else
        error "Registry not found: $SKILL_REGISTRY"
        ((issues++))
    fi

    # Skills validity
    if [[ -d "$SKILL_REGISTRY" ]]; then
        local skill_count=0 broken=0
        for dir in "$SKILL_REGISTRY"/*/; do
            [[ -d "$dir" ]] || continue
            ((skill_count++))
            if [[ ! -f "$dir/SKILL.md" ]]; then
                warn "Missing SKILL.md: $(basename "$dir")"
                ((broken++))
                ((issues++))
            fi
        done
        if [[ $broken -eq 0 && $skill_count -gt 0 ]]; then
            success "Skills: $skill_count in registry, all valid"
        fi
    fi

    # Dependencies
    if command -v bun &>/dev/null; then
        success "bun: $(bun --version)"
    else
        warn "bun not found (needed for TypeScript skills)"
        ((issues++))
    fi

    if command -v gum &>/dev/null; then
        success "gum: $(gum --version 2>&1 | head -1)"
    else
        error "gum not found — install with: brew install gum"
        ((issues++))
    fi

    # Binary freshness
    local installed_script
    installed_script="$(command -v ccskill 2>/dev/null || echo "")"
    if [[ -n "$installed_script" ]]; then
        local git_root
        git_root="$(registry_git_root)"
        if [[ -n "$git_root" && -f "$git_root/ccskill" ]]; then
            local real_installed real_source
            real_installed="$(realpath "$installed_script")"
            real_source="$(realpath "$git_root/ccskill")"
            if [[ "$real_installed" == "$real_source" ]]; then
                success "Binary: running from source"
            elif diff -q "$real_installed" "$real_source" &>/dev/null; then
                success "Binary: up to date"
            else
                warn "Binary: outdated — run 'ccskill upgrade'"
                ((issues++))
            fi
        fi
    fi

    # Installed skills freshness
    for target in claude codex; do
        local project_dir
        project_dir="$(target_dir "$target")"
        [[ -d "$project_dir" ]] || continue

        local stale=0 count=0
        for skill_dir in "$project_dir"/*/; do
            [[ -f "$skill_dir/SKILL.md" ]] || continue
            ((count++))
            local skill_name
            skill_name="$(basename "$skill_dir")"
            if [[ -d "$SKILL_REGISTRY/$skill_name" ]] && ! diff -rq "$SKILL_REGISTRY/$skill_name" "$skill_dir" &>/dev/null; then
                ((stale++))
            fi
        done
        if [[ $stale -gt 0 ]]; then
            warn "$(target_label "$target"): $stale skill(s) outdated — run 'ccskill update'"
            ((issues++))
        elif [[ $count -gt 0 ]]; then
            success "$(target_label "$target"): $count skill(s), all current"
        fi
    done

    echo ""
    if [[ $issues -eq 0 ]]; then
        success "No issues found"
    else
        warn "$issues issue(s) found"
    fi
}

# ============================================================================
# Main
# ============================================================================

# Parse flags
args=()
while [[ $# -gt 0 ]]; do
    case "$1" in
        -y|--yes)
            YES_FLAG=true
            shift
            ;;
        *)
            args+=("$1")
            shift
            ;;
    esac
done
set -- "${args[@]}"

case "${1:-help}" in
    list)       cmd_list ;;
    status)     cmd_status ;;
    info)       cmd_info "${2:-}" ;;
    add)        cmd_add "${2:-}" ;;
    remove|rm)  cmd_remove "${2:-}" ;;
    update|up)  cmd_update "${2:-}" ;;
    sync)       cmd_sync ;;
    upgrade)    cmd_upgrade ;;
    doctor)     cmd_doctor ;;
    init)       cmd_init ;;
    help|--help|-h) cmd_help ;;
    *)          error "Unknown command: $1"; cmd_help; exit 1 ;;
esac
